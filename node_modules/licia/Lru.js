function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

var LinkedList = require('./LinkedList');
var PseudoMap = require('./PseudoMap');

exports = (function() {
    function Lru(max) {
        _classCallCheck(this, Lru);

        this._max = max;
        this._list = new LinkedList();
        this._map = new PseudoMap();
    }

    _createClass(Lru, [
        {
            key: 'has',
            value: function has(key) {
                return this._map.has(key);
            }
        },
        {
            key: 'remove',
            value: function remove(key) {
                var map = this._map;

                if (this.has(key)) {
                    var node = map.get(key);

                    this._list.rmNode(node);

                    map.delete(key);
                }
            }
        },
        {
            key: 'get',
            value: function get(key) {
                var list = this._list;
                var map = this._map;
                var ret;

                if (this.has(key)) {
                    var node = map.get(key);
                    ret = node.value.val;
                    list.rmNode(node);
                    list.unshift(node.value);
                    map.set(key, list.head);
                }

                return ret;
            }
        },
        {
            key: 'set',
            value: function set(key, val) {
                var list = this._list;
                var map = this._map;

                if (this.has(key)) {
                    var node = map.get(key);
                    list.rmNode(node);
                    list.unshift({
                        key: key,
                        val: val
                    });
                    map.set(key, list.head);
                } else {
                    list.unshift({
                        key: key,
                        val: val
                    });
                    map.set(key, list.head);

                    if (list.size > this._max) {
                        var item = list.pop();
                        map.delete(item.key);
                    }
                }
            }
        },
        {
            key: 'clear',
            value: function clear() {
                this._map = new PseudoMap();
                this._list = new LinkedList();
            }
        }
    ]);

    return Lru;
})();

module.exports = exports;
